---
title: "ECR-721"
tags: ["Solidity", "Payment", "App"]
---

# Description

ECR 721 Interface:

```sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

interface IERC165 {
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

interface IERC721 is IERC165 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(
        address owner,
        address operator
    ) external view returns (bool);
}

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}
```

---

# Tasks

## 1

Complete the function ownerOf

- function ownerOf(uint256 id) external view returns (address) {}
- Return the owner of id stored in _ownerOf
- Fail if token does not exist (_ownerOf[id] is zero address)

## 2

Complete the function balanceOf


`function balanceOf(address owner) external view returns (uint256) {}`

- Return the balance of owner stored in _balanceOf
- Fail if owner is zero address

## 3

Complete the function mint

This function is not part of ERC721 but it will be used for later tests.

```
function mint(address dst, uint256 id) external {
    // code
}
```

- Create new token having token id equal to id, owner set to dst
- dst cannot be zero address
- token must not exist yet
- Emit Transfer from zero address, to dst with token id id

## 4

Complete the function setApprovalForAll

```
function setApprovalForAll(address operator, bool approved) external {
    // code
}
```
This function enable or disable approval for a third party ("operator") to manage all of msg.sender's tokens

- set isApprovedForAll from msg.sender to operator to approved
- Emit ApprovalForAll

## 5

Complete the function getApproved

```
function getApproved(uint256 id) external view returns (address) {}
```

- Returns the address allowed to transfer id
- Fails if token does not exist

## 6

Complete the function approve

```
function approve(address spender, uint256 id) external {
    // code
}
```

This function approves spender to transfer token id on behalf of the owner

Set _approvals for id to spender
Emit Approval
Fail if msg.sender is not owner or if owner has not approved msg.sender as an operator

## 7

Complete the function transferFrom

```
function transferFrom(
    address src,
    address dst,
    uint256 id
) public {
    // code
}
```

- Transfer id from src to dst
- Reset _approvals for id
- Emit Transfer
- Fail if token does not exist
- Fail if src is not owner of id
- Fail if dst is zero address
- Fail if msg.sender is not owner or if owner has not approved msg.sender

## 8

Complete the function safeTransferFrom

```
function safeTransferFrom(
    address src,
    address to,
    uint256 id
) external  {
    // code
}
```

This function is same as transferFrom except it will call the function onERC721Received if dst is a contract

Here is the interface for IERC721Receiver

```
interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address src,
        uint256 id,
        bytes calldata data
    ) external returns (bytes4);
}
```

- Transfers id from src to dst
- Reset _approvals for id
- Emit Transfer
- If dst is a contract call onERC721REceived, passing empty bytes ("") for data
- If dst is a contract check that onERC721Received returns IERC721Receiver.onERC721Received.selector
- Fail if token does not exist
- Fail if src is not owner of id
- Fail if dst is zero address
- Fail if msg.sender is not owner or if owner has not approved msg.sender

## 9

Complete the function safeTransferFrom

```
function safeTransferFrom(
    address src,
    address dst,
    uint256 id,
    bytes calldata data
) external {
    // code
}
```

This function is same as safeTransferFrom(address src, address dst, uint256 id) except it will call the function onERC721Received with data.

This function should

- Transfers id from src to dst
- Reset _approvals for id
- Emit Transfer
- If dst is a contract call onERC721REceived with data
- If dst is a contract check that onERC721Received returns IERC721Receiver.onERC721Received.selector
- Fail if token does not exist
- Fail if src is not owner of id
- Fail if dst is zero address
- Fail if msg.sender is not owner or if owner has not approved msg.sender

## 10

Complete the function burn

```
function burn(uint256 id) external {
    // code
}
```

This function is not part of ERC721.

- Delete token with id
- Clear all approvals
- Emit Transfer to zero address
- Fail if token does not exist
- Fail if msg.sender is not the owner of id

---

# Solution

```sol
// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IERC721, IERC721Receiver, IERC165} from "sce/sol/IERC721.sol";

contract ERC721 is IERC721 {
    event Transfer(
        address indexed src, address indexed dst, uint256 indexed id
    );
    event Approval(
        address indexed owner, address indexed spender, uint256 indexed id
    );
    event ApprovalForAll(
        address indexed owner, address indexed operator, bool approved
    );

    // Mapping from token ID to owner address
    mapping(uint256 => address) internal _ownerOf;
    // Mapping owner address to token count
    mapping(address => uint256) internal _balanceOf;
    // Mapping from token ID to approved address
    mapping(uint256 => address) internal _approvals;
    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) public isApprovedForAll;


    function supportsInterface(bytes4 interfaceId)
        external
        pure
        returns (bool)
    {
        return interfaceId == type(IERC721).interfaceId
            || interfaceId == type(IERC165).interfaceId;
    }

    function ownerOf(uint256 id) external view returns (address)  {
        require(_ownerOf[id] != address(0), "Address does not exists");
        return _ownerOf[id];
    }

    function balanceOf(address owner) external view returns (uint256) {
        require(address(0) != owner, "Invalid owner address");
        return _balanceOf[owner];
    }

    function setApprovalForAll(address operator, bool approved) external {
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function getApproved(uint256 id) external view returns (address) {
        require(_ownerOf[id] != address(0), "Token does not exist");
        return _approvals[id];
    }

    function approve(address spender, uint256 id) external  {
        require(_ownerOf[id] == msg.sender || isApprovedForAll[_ownerOf[id]][msg.sender] == true, "Invalid token owner");
        _approvals[id] = spender;
        emit Approval(msg.sender, spender, id);
    }

    function transferFrom(address src, address dst, uint256 id) public {
        require(address(0) != dst, "Invalid dst address");
        require(src == _ownerOf[id], "Invalid src address");
        require(_ownerOf[id] != address(0), "Token does not exist");
        require(isApprovedForAll[src][msg.sender] == true || _ownerOf[id] == msg.sender || _approvals[id] == msg.sender, "Invalid token owner");
        
        _ownerOf[id] = dst;
        _balanceOf[src] -= 1;
        _balanceOf[dst] += 1;
        _approvals[id] = address(0);
        
        emit Transfer(src, dst, id);
    }

    function safeTransferFrom(address src, address dst, uint256 id) external {
        transferFrom(src, dst, id);
        
        // check if dst is a contract
        if (dst.code.length > 0) {
            (bool success, bytes memory data) =
                dst.call(
                    abi.encodeWithSignature(
                        "onERC721Received(address,address,uint256,bytes)", 
                        msg.sender,
                        src,
                        id,
                        bytes("")
                ));
            require(success, "onERC721Received call failed");
            require(IERC721Receiver.onERC721Received.selector == abi.decode(data, (bytes4)), "Invalid onERC721Received return val");
        }
    }

    function safeTransferFrom(
        address src,
        address dst,
        uint256 id,
        bytes calldata data
    ) external {
        transferFrom(src, dst, id);
        
        // check if dst is a contract
        if (dst.code.length > 0) {
            (bool success, bytes memory retData) =
                dst.call(
                    abi.encodeWithSignature(
                        "onERC721Received(address,address,uint256,bytes)", 
                        msg.sender,
                        src,
                        id,
                        data
                ));
            require(success, "onERC721Received call failed");
            require(
                IERC721Receiver.onERC721Received.selector == 
                abi.decode(retData, (bytes4))
                , "Invalid onERC721Received return val");
        }
    }
    


    function mint(address dst, uint256 id) external {
        require(address(0) != dst, "Invalid dst address");
        require(_ownerOf[id] == address(0), "Token id is minted");
        
        _ownerOf[id] = dst;
        _balanceOf[dst] += 1;
        
        emit Transfer(address(0), dst, id);
    }

    function burn(uint256 id) external {
        require(_ownerOf[id] != address(0), "token does not exist");
        require(msg.sender == _ownerOf[id], "Msg sender is not the owner");
        _balanceOf[_ownerOf[id]] -= 1;
        _ownerOf[id] = address(0);
        _approvals[id] = address(0);
        emit Transfer(msg.sender, address(0), id);
    }
}
```
